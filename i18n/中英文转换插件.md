```js
import createNextIntlPlugin from 'next-intl/plugin'
import fs from 'fs'
import path from 'path'

// 加载中文到英文的映射
const loadZhToEnMap = () => {
  const zhPath = path.join(process.cwd(), 'messages', 'zh')
  const map = new Map()

  fs.readdirSync(zhPath).forEach((file) => {
    if (!file.endsWith('.json')) return
    const namespace = file.replace('.json', '')
    const content = JSON.parse(
      fs.readFileSync(path.join(zhPath, file), 'utf-8')
    )

    Object.entries(content).forEach(([key, value]) => {
      if (typeof value === 'string') {
        map.set(value, { key, namespace })
      }
    })
  })

  return map
}

const zhToEnMap = loadZhToEnMap()

/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    unoptimized: false,
  },
  webpack: (config, { dev }) => {
    // 只在生产环境转换
    if (!dev) {
      config.module.rules.push({
        test: /\.[jt]sx?$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'string-replace-loader',
            options: {
              search: /t\(['"]([^'"]+)['"]\)/g,
              replace: (match, zhKey) => {
                const mapping = zhToEnMap.get(zhKey)
                return mapping ? `t('${mapping.key}')` : match
              },
            },
          },
        ],
      })
    }
    return config
  },
}

const withNextIntl = createNextIntlPlugin()

export default withNextIntl(nextConfig)
```

您提出了一个非常好的问题！确实，在一个组件内可能需要使用多个不同 namespace 的翻译。这种情况下，当前的替换方案会有局限性。我来分析一下这个问题并提供几种可能的解决方案。

### 问题分析

当前的替换逻辑：

```javascript
{
  pattern: /const\s+t\s*=\s*useI18n\(\s*(?:['"]([^'"]+)['"])?\s*\)/g,
  replace: (match, namespace) => {
    const ns = namespace || 'common'
    return `const t = useTranslations('${ns}')`
  }
}
```

这种方式只能处理单个 namespace 的情况。如果组件中有多个 namespace 的需求，例如：

```jsx
function MyComponent() {
  const t1 = useI18n('form')
  const t2 = useI18n('common')

  return (
    <div>
      <h1>{t1('表单标题')}</h1>
      <p>{t2('版权信息')}</p>
    </div>
  )
}
```

当前的替换逻辑会将其转换为：

```jsx
function MyComponent() {
  const t1 = useTranslations('form')
  const t2 = useTranslations('common')

  // 但t1('表单标题')的替换可能会有问题，因为替换逻辑可能只针对t而不是t1
}
```

### 解决方案

#### 方案 1：支持多个命名的 t 函数

修改替换逻辑，使其能够识别不同命名的 t 函数：

```javascript
{
  // 处理useI18n的调用，支持任意变量名
  pattern: /const\s+(\w+)\s*=\s*useI18n\(\s*(?:['"]([^'"]+)['"])?\s*\)/g,
  replace: (match, varName, namespace) => {
    const ns = namespace || 'common'
    return `const ${varName} = useTranslations('${ns}')`
  }
},
{
  // 处理不带namespace参数的t调用，支持任意变量名
  pattern: /(\w+)\(['"]([^'"]+)['"]\)/g,
  replace: (match, varName, zhKey) => {
    // 需要判断varName是否是一个t函数
    // 这可能需要更复杂的静态分析
    const mapping = zhToEnMap.get(zhKey)
    if (mapping) {
      return `${varName}('${mapping.key}')`
    }
    return match
  }
}
```

这种方案的挑战在于需要进行更复杂的静态代码分析，以确定哪些变量是 t 函数。

#### 方案 2：使用命名空间对象

改变 API 设计，使`useI18n`返回一个包含所有 namespace 的对象：

```typescript
// 开发环境
export function useI18n() {
  const namespaces = ['common', 'form', 'git' /* 其他namespace */]

  const result: Record<string, (zhKey: string) => string> = {}

  namespaces.forEach((ns) => {
    const trans = useTranslations(ns)

    result[ns] = (zhKey: string) => {
      const mapping = zhToEnCache[zhKey]
      if (!mapping) {
        console.warn(`[i18n] 未找到中文key "${zhKey}" 的映射`)
        return zhKey
      }

      return trans(mapping.key)
    }
  })

  return result
}
```

使用方式：

```jsx
function MyComponent() {
  const t = useI18n()

  return (
    <div>
      <h1>{t.form('表单标题')}</h1>
      <p>{t.common('版权信息')}</p>
    </div>
  )
}
```

构建时替换：

```javascript
{
  // 处理t.namespace('中文')的调用
  pattern: /t\.(\w+)\(['"]([^'"]+)['"]\)/g,
  replace: (match, namespace, zhKey) => {
    const mapping = zhToEnMap.get(zhKey)
    if (mapping) {
      return `useTranslations('${namespace}')('${mapping.key}')`
    }
    return match
  }
}
```

#### 方案 3：使用高阶组件或 Context

创建一个翻译 Provider，在应用顶层提供所有 namespace 的翻译：

```jsx
// i18n-provider.tsx
export const TranslationContext = createContext({})

export function TranslationProvider({ children }) {
  const namespaces = ['common', 'form', 'git' /* 其他namespace */]

  const translations = {}

  namespaces.forEach((ns) => {
    translations[ns] = useTranslations(ns)
  })

  const t = (zhKey: string, namespace = 'common') => {
    const mapping = zhToEnCache[zhKey]
    if (!mapping) {
      console.warn(`[i18n] 未找到中文key "${zhKey}" 的映射`)
      return zhKey
    }

    const ns = namespace || mapping.namespace || 'common'
    return translations[ns](mapping.key)
  }

  return (
    <TranslationContext.Provider value={{ t, translations }}>
      {children}
    </TranslationContext.Provider>
  )
}

// 使用hook
export function useI18n() {
  return useContext(TranslationContext)
}
```

使用方式：

```jsx
function MyComponent() {
  const { t } = useI18n()

  return (
    <div>
      <h1>{t('表单标题', 'form')}</h1>
      <p>{t('版权信息')}</p> {/* 默认使用common */}
    </div>
  )
}
```

构建时替换：

```javascript
{
  // 处理t('中文', 'namespace')的调用
  pattern: /t\(['"]([^'"]+)['"]\s*(?:,\s*['"]([^'"]+)['"])?\)/g,
  replace: (match, zhKey, namespace = 'common') => {
    const mapping = zhToEnMap.get(zhKey)
    if (mapping) {
      const ns = namespace || mapping.namespace || 'common'
      return `translations['${ns}']('${mapping.key}')`
    }
    return match
  }
}
```

#### 方案 4：动态创建 t 函数工厂

创建一个函数工厂，可以动态生成针对特定 namespace 的 t 函数：

```typescript
export function useI18n() {
  const namespaces = ['common', 'form', 'git' /* 其他namespace */]
  const transMap = {}

  namespaces.forEach((ns) => {
    transMap[ns] = useTranslations(ns)
  })

  // 默认t函数使用common namespace
  const t = (zhKey: string, namespace = 'common') => {
    const mapping = zhToEnCache[zhKey]
    if (!mapping) {
      console.warn(`[i18n] 未找到中文key "${zhKey}" 的映射`)
      return zhKey
    }

    const ns = namespace || mapping.namespace || 'common'
    return transMap[ns](mapping.key)
  }

  // 添加创建特定namespace t函数的方法
  t.use = (namespace: string) => {
    return (zhKey: string) => {
      const mapping = zhToEnCache[zhKey]
      if (!mapping) {
        console.warn(`[i18n] 未找到中文key "${zhKey}" 的映射`)
        return zhKey
      }

      return transMap[namespace](mapping.key)
    }
  }

  return t
}
```

使用方式：

```jsx
function MyComponent() {
  const t = useI18n()
  const tForm = t.use('form')
  const tGit = t.use('git')

  return (
    <div>
      <h1>{tForm('表单标题')}</h1>
      <button>{tForm('提交')}</button>
      <button>{tGit('提交')}</button> {/* 不同namespace的同一中文 */}
      <p>{t('版权信息')}</p> {/* 默认使用common */}
    </div>
  )
}
```

### 推荐方案

考虑到易用性、可维护性和构建时替换的复杂度，我推荐**方案 2**或**方案 4**：

- **方案 2（命名空间对象）**：API 清晰，使用简单，构建时替换也相对直接。
- **方案 4（动态工厂）**：更灵活，支持默认 namespace 和特定 namespace 的混合使用。

这两种方案都能很好地解决一个组件内多 namespace 的问题，同时保持代码的可读性和可维护性。

您觉得哪种方案更适合您的项目需求？
