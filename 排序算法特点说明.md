# 十大排序算法特点说明

## 1. 冒泡排序 (Bubble Sort)

- **基本思想**：通过相邻元素的比较和交换，使较大的元素逐渐"浮"向数组末尾
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)
- **稳定性**：稳定
- **特点**：
  - 实现简单，容易理解
  - 对于小规模或接近有序的数据效率较高
  - 多次遍历导致效率较低，不适合大规模数据
  - 每轮遍历后最大元素会沉到末尾

## 2. 选择排序 (Selection Sort)

- **基本思想**：每次从未排序部分选出最小元素，放到已排序部分的末尾
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)
- **稳定性**：不稳定
- **特点**：
  - 实现简单
  - 交换次数少，适合交换成本高的场景
  - 无论输入如何，时间复杂度始终为 O(n²)
  - 对几乎有序的数据没有优势

## 3. 插入排序 (Insertion Sort)

- **基本思想**：将未排序元素逐个插入到已排序部分的适当位置
- **时间复杂度**：最好 O(n)，平均和最坏 O(n²)
- **空间复杂度**：O(1)
- **稳定性**：稳定
- **特点**：
  - 对于小规模或几乎排序好的数据效率极高
  - 适合在线算法，可以边接收数据边排序
  - 实现简单，代码量小
  - 比冒泡排序和选择排序更高效

## 4. 希尔排序 (Shell Sort)

- **基本思想**：插入排序的改进版，通过设置间隔分组进行排序，逐渐减小间隔
- **时间复杂度**：取决于间隔序列，一般为 O(n^1.3)~O(n²)
- **空间复杂度**：O(1)
- **稳定性**：不稳定
- **特点**：
  - 第一个突破 O(n²)的排序算法
  - 对中等规模数据表现良好
  - 间隔序列的选择对性能影响很大
  - 最后一轮间隔为 1 时等价于插入排序，但此时数据已接近有序

## 5. 归并排序 (Merge Sort)

- **基本思想**：分治法，将数组分为两半分别排序，然后合并
- **时间复杂度**：O(nlogn)
- **空间复杂度**：O(n)
- **稳定性**：稳定
- **特点**：
  - 性能稳定，无论输入如何都是 O(nlogn)
  - 分治思想的典型应用
  - 适合外部排序和大规模数据
  - 需要额外空间存储合并结果

## 6. 快速排序 (Quick Sort)

- **基本思想**：选取基准元素，将数组分为小于和大于基准的两部分
- **时间复杂度**：平均 O(nlogn)，最坏 O(n²)
- **空间复杂度**：O(logn)（递归调用栈）
- **稳定性**：不稳定
- **特点**：
  - 实际应用中平均性能最好的排序算法
  - 原地排序，不需要额外存储空间
  - 基准元素的选择对性能影响很大
  - 递归实现，可能导致栈溢出
  - 对接近有序的数据可能退化为 O(n²)

## 7. 堆排序 (Heap Sort)

- **基本思想**：利用堆这种数据结构所设计的排序算法
- **时间复杂度**：O(nlogn)
- **空间复杂度**：O(1)
- **稳定性**：不稳定
- **特点**：
  - 性能稳定，无论输入如何都是 O(nlogn)
  - 原地排序，不需要额外空间
  - 适合大数据量排序
  - 建堆过程消耗较大
  - 不适合递增序列

## 8. 计数排序 (Counting Sort)

- **基本思想**：统计每个元素出现的次数，适用于有限范围整数
- **时间复杂度**：O(n+k)，k 为数据范围
- **空间复杂度**：O(k)
- **稳定性**：稳定
- **特点**：
  - 非比较排序，速度很快
  - 适用于数据范围不大的情况
  - 当数据范围 k 很大时会占用大量空间
  - 只适用于整数排序

## 9. 桶排序 (Bucket Sort)

- **基本思想**：将元素分到有限数量的桶中，每个桶再单独排序
- **时间复杂度**：平均 O(n+k)，最坏 O(n²)
- **空间复杂度**：O(n+k)
- **稳定性**：取决于桶内排序算法
- **特点**：
  - 非比较排序，可以突破 O(nlogn)的下限
  - 适合均匀分布的数据
  - 桶的数量和分布影响性能
  - 需要额外空间
  - 每个桶内部需要再次排序

## 10. 基数排序 (Radix Sort)

- **基本思想**：按照个位、十位、百位等逐位比较排序
- **时间复杂度**：O(d(n+k))，d 为位数，k 为基数
- **空间复杂度**：O(n+k)
- **稳定性**：稳定
- **特点**：
  - 非比较排序，可以突破 O(nlogn)的下限
  - 适合数据位数不多的情况
  - 需要多次遍历
  - 对于负数需要特殊处理
  - 适合字符串和整数排序

## 排序算法的比较

| 排序算法 | 平均时间复杂度 | 最好情况  | 最坏情况  | 空间复杂度 | 稳定性 | 适用场景             |
| -------- | -------------- | --------- | --------- | ---------- | ------ | -------------------- |
| 冒泡排序 | O(n²)          | O(n)      | O(n²)     | O(1)       | 稳定   | 小规模，接近有序     |
| 选择排序 | O(n²)          | O(n²)     | O(n²)     | O(1)       | 不稳定 | 小规模，交换成本高   |
| 插入排序 | O(n²)          | O(n)      | O(n²)     | O(1)       | 稳定   | 小规模，几乎有序     |
| 希尔排序 | O(n^1.3)~O(n²) | O(n^1.3)  | O(n²)     | O(1)       | 不稳定 | 中等规模             |
| 归并排序 | O(nlogn)       | O(nlogn)  | O(nlogn)  | O(n)       | 稳定   | 大规模，稳定性要求高 |
| 快速排序 | O(nlogn)       | O(nlogn)  | O(n²)     | O(logn)    | 不稳定 | 大多数实际应用       |
| 堆排序   | O(nlogn)       | O(nlogn)  | O(nlogn)  | O(1)       | 不稳定 | 大规模，空间受限     |
| 计数排序 | O(n+k)         | O(n+k)    | O(n+k)    | O(k)       | 稳定   | 整数，范围有限       |
| 桶排序   | O(n+k)         | O(n+k)    | O(n²)     | O(n+k)     | 稳定   | 均匀分布数据         |
| 基数排序 | O(d(n+k))      | O(d(n+k)) | O(d(n+k)) | O(n+k)     | 稳定   | 数字和字符串         |
