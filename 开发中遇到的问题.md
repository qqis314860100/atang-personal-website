# 1.RLS(Row level security),行级安全

为数据库表创建访问策略（policy），以约束数据的可见性.用户访问该表时,如果 policy 生效,则会根据 policy 中定义的过滤条件来决定用户可操作的数据集合.

`permission denied for schema public（代码：42501`

1. 临时在 Supabase 中禁用 RLS（快速解决）
   点击 "RLS" 按钮禁用行级安全策略
2.

```sql
-- 4. 创建索引
CREATE INDEX "PDFAnnotation_pdfUrl_idx" ON "PDFAnnotation"("pdfUrl");
CREATE INDEX "PDFAnnotation_userId_idx" ON "PDFAnnotation"("userId");
CREATE INDEX "PDFAnnotation_userId_pdfUrl_idx" ON "PDFAnnotation"("userId", "pdfUrl");

-- 6. 授予权限
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO postgres;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO authenticated;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO anon;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO service_role;

-- 7. 启用 RLS
ALTER TABLE "PDFAnnotation" ENABLE ROW LEVEL SECURITY;

-- 8. 创建策略
CREATE POLICY "用户只能查看自己的注释" ON "PDFAnnotation"
  FOR SELECT USING (auth.uid()::text = "userId");

CREATE POLICY "用户只能插入自己的注释" ON "PDFAnnotation"
  FOR INSERT WITH CHECK (auth.uid()::text = "userId");

CREATE POLICY "用户只能更新自己的注释" ON "PDFAnnotation"
  FOR UPDATE USING (auth.uid()::text = "userId");

CREATE POLICY "用户只能删除自己的注释" ON "PDFAnnotation"
  FOR DELETE USING (auth.uid()::text = "userId");

-- 9.为用户角色授权 public schema 权限。
-- 之前：用户有数据库 CREATE 权限就能在 public schema 中创建表
-- 现在：需要明确授权用户对 public schema 的权限

-- 为 authenticated 角色授权 public schema 权限
GRANT ALL ON SCHEMA public TO authenticated;

-- 为 anon 角色授权 public schema 权限（如果需要）
GRANT ALL ON SCHEMA public TO anon;

-- 为 service_role 角色授权 public schema 权限
GRANT ALL ON SCHEMA public TO service_role;

-- 确保所有表都有正确的权限
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO anon;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;

-- 为将来创建的表设置默认权限
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO service_role;
```

# 2.变更表结构同步到 Supabase

在开发阶段将 Prisma Schema 更新同步到 Supabase 的步骤：

### 1. 生成迁移 SQL

首先，使用 Prisma 生成迁移文件：

```bash
npx prisma migrate dev --name update_user_profile_schema
```

这会在 `prisma/migrations` 目录下生成包含 SQL 语句的迁移文件。

### 2. 将迁移应用到 Supabase

#### 方法一：使用 Supabase SQL 编辑器

1. 登录 [Supabase 控制台](https://app.supabase.com)
2. 选择您的项目
3. 进入 "SQL 编辑器" 标签
4. 创建新查询
5. 复制 Prisma 迁移文件中的 SQL 语句
6. 在 SQL 编辑器中粘贴并执行这些语句

#### 方法二：使用 Prisma 直接连接 Supabase（如果配置了直接连接）

如果您已经配置了 Prisma 直接连接 Supabase 数据库，可以执行：

```bash
DATABASE_URL=your_supabase_connection_string npx prisma migrate deploy
```

### 3. 更新本地 Prisma 客户端

应用迁移后，更新 Prisma 客户端：

```bash
npx prisma generate
```

### 4. 验证更改

在 Supabase 控制台中，进入 "表编辑器" 确认 `UserProfile` 表结构是否已正确更新：

- 检查是否添加了 `date` 字段
- 确认 `school` 字段是否已被移除或重命名
- 验证其他更改是否正确应用

### 提示与技巧

1. **开发中频繁更新**：在开发阶段频繁更改 schema 时，可以考虑：

   ```bash
   npx prisma db push
   ```

   这会直接将 schema 变更推送到数据库，但不会生成迁移历史

2. **导入与导出数据**：如果需要保留数据，可以先在 Supabase 中导出数据，应用迁移后再导入

3. **重置开发环境**：如果只是开发环境且数据不重要，可以考虑完全重置数据库：
   ```sql
   -- 在 Supabase SQL 编辑器中执行
   DROP SCHEMA public CASCADE;
   CREATE SCHEMA public;
   GRANT ALL ON SCHEMA public TO postgres;
   GRANT ALL ON SCHEMA public TO public;
   ```
   然后重新应用全部迁移

# 3.水和不匹配问题

1. **完全客户端渲染**：通过使用`mounted`状态和`useEffect`，确保 Toaster 和 TopLoader 组件只在客户端渲染，避免了服务器端和客户端之间的差异

2. **条件渲染**：服务器渲染时返回`null`，客户端挂载后才渲染实际组件

3. **明确的生命周期**：使用`useEffect`清晰地控制组件的挂载/卸载行为

通过这些改进，现在不应该再出现水合不匹配错误。这种方法是处理那些在服务器和客户端渲染结果不同的组件的最可靠方式。

4. 组件渲染的三个阶段
   - 服务器渲染：返回 null（不渲染任何内容）
   - 客户端初始渲染（水合）：返回 null（与服务器渲染结果匹配）
   - 客户端 useEffect 执行后：mounted=true，渲染实际组件
   - 这种模式特别适合处理那些依赖于浏览器环境、随机性、或会产生不一致渲染结果的组件，比如 toast 通知、进度条等 UI 元素。
   - 简而言之，这是一种"延迟客户端渲染"的技术，先确保水合成功，然后再在纯客户端环境中渲染实际内容。

# 4.什么时候用 Server Action?什么时候用 API 路由?

## 1. Server Action（服务器动作）

- **本质**：直接在服务端运行的函数，可以在组件/页面中直接调用（如 `await updateUser(data)`）。
- **调用方式**：只能在服务端（如 React Server Component、`app` 目录的 `server` 组件、或 `use server` 的 action）直接调用，不能被浏览器直接请求。
- **优点**：
  - 类型安全，参数和返回值都在同一个 TypeScript 项目里。
  - 无需手动写 API 路由，直接 import 调用。
  - 适合表单提交、数据处理、数据库操作等。
- **缺点**：
  - 只能在 Next.js 的服务端环境下用，不能被外部系统或 Postman 直接访问。
  - 不能处理 multipart/form-data（如文件上传）等特殊请求（目前）。

**你的 `actions/updateUser.ts` 就是一个 Server Action：**

```ts
// 只能在服务端直接 import 并调用
import { updateUser } from '@/actions/updateUser'
await updateUser(data)
```

---

## 2. API 路由（API Route）

- **本质**：一个 HTTP 接口（如 `/api/xxx`），可以被前端 fetch、axios、外部系统、Postman 等直接请求。
- **调用方式**：通过 HTTP 请求（GET/POST/PUT/DELETE），前端用 `fetch('/api/xxx')` 调用。
- **优点**：
  - 灵活，支持各种 HTTP 请求和内容类型（如文件上传）。
  - 可被任何客户端或第三方系统访问。
- **缺点**：
  - 需要手动处理请求体、参数校验、返回格式等。
  - 类型安全性不如 Server Action。

**API 路由例子：**

```ts
// app/api/update-user/route.ts
export async function POST(req: Request) {
  const data = await req.json()
  // ...处理逻辑
  return Response.json({ success: true })
}
```

### 2.1. `app/api/pdf2md/route.ts`（App Router 新写法）

- **属于 Next.js 13+ 的 App Router（app 目录）体系。**
- 文件路径：`app/api/pdf2md/route.ts`
- **导出方式**：导出 `GET`、`POST` 等函数（如 `export async function POST()`）。
- **支持特性**：
  - 支持 Edge/Server 运行时（可选）。
  - 支持中间件、流式响应等新特性。
  - 推荐用于新项目和未来维护。
- **调用方式**：前端 `fetch('/api/pdf2md', { method: 'POST', ... })`。

**示例：**

```ts
// app/api/pdf2md/route.ts
export async function POST(req: Request) {
  // 处理逻辑
  return Response.json({ markdown: '...' })
}
```

---

### 2.2 `pages/api/pdf2md.ts`（Pages Router 传统写法）

- **属于 Next.js 12 及以前的 Pages Router（pages 目录）体系。**
- 文件路径：`pages/api/pdf2md.ts`
- **导出方式**：导出一个默认的 handler 函数（`(req, res) => {}`）。
- **支持特性**：
  - 兼容老项目，写法和 Express 类似。
  - 不支持 Edge Runtime、流式响应等新特性。
  - 未来 Next.js 官方推荐逐步迁移到 app 目录。
- **调用方式**：前端 `fetch('/api/pdf2md', { method: 'POST', ... })`。

**示例：**

```ts
// pages/api/pdf2md.ts
export default async function handler(req, res) {
  // 处理逻辑
  res.status(200).json({ markdown: '...' })
}
```

---

## 3. 总结对比表

| 特性/区别        |   `app/api/pdf2md/route.ts`    |    `pages/api/pdf2md.ts`    |
| ---------------- | :----------------------------: | :-------------------------: |
| 所属体系         |     App Router（新，推荐）     |  Pages Router（老，兼容）   |
| Next.js 版本     |        13+（app 目录）         |   12 及以前（pages 目录）   |
| 导出方式         | `export async function POST()` | `export default function()` |
| Edge/Server 支持 |    支持 Edge/Server 运行时     |      仅 Node.js 运行时      |
| 新特性           |     支持流式响应、中间件等     |           不支持            |
| 官方推荐         |      新项目/未来维护优先       |        旧项目/兼容性        |

## 3. 什么时候用 Server Action，什么时候用 API 路由？

- **表单、按钮、数据更新**（只在 Next.js 内部用）：优先用 Server Action，代码更简洁、类型安全。
- **需要被外部系统/第三方/前端 fetch 调用**：用 API 路由。
- **文件上传、特殊请求体**：目前只能用 API 路由。

---

## 4. 你的项目举例

- `actions/updateUser.ts` 适合在 Next.js 内部直接调用（如表单提交）。
- 如果你要做“PDF 转 Markdown”，**必须用 API 路由**，因为要处理 multipart/form-data 文件上传，Server Action 暂不支持。

---

## 总结

| 场景          | Server Action（actions/xxx.ts） | API 路由（api/xxx/route.ts） |
| ------------- | :-----------------------------: | :--------------------------: |
| 内部表单/按钮 |            推荐使用             |             可用             |
| 外部系统调用  |              不行               |             推荐             |
| 文件上传      |              不行               |             推荐             |
| 类型安全      |             非常好              |          需手动校验          |

---

如需具体代码示例或集成建议，请随时告知！

# 5.通过 SQL 创建表可能导致权限问题

```SQL
-- 创建表后，可以运行以下SQL检查权限：
SELECT
    grantee,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE table_name = 'your_table_name'
ORDER BY grantee, privilege_type;

-- 如果没有权限

-- 1. 授予所有权限给 postgres 用户（表所有者）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO postgres;

-- 2. 授予所有权限给 authenticated 角色（认证用户）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO authenticated;

-- 3. 授予所有权限给 anon 角色（匿名用户）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO anon;

-- 4. 授予所有权限给 service_role 角色（服务角色）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO service_role;

```

## 5.1 预防措施

### 5.1.1 使用 Supabase Dashboard 创建表

- 通过 Dashboard 创建表会自动配置正确的权限,避免直接使用 SQL 创建表
