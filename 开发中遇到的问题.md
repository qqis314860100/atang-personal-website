# 1.RLS(Row level security),行级安全

为数据库表创建访问策略（policy），以约束数据的可见性.用户访问该表时,如果 policy 生效,则会根据 policy 中定义的过滤条件来决定用户可操作的数据集合.

`permission denied for schema public（代码：42501`

1. 临时在 Supabase 中禁用 RLS（快速解决）
   点击 "RLS" 按钮禁用行级安全策略
2.

```sql
-- 4. 创建索引
CREATE INDEX "PDFAnnotation_pdfUrl_idx" ON "PDFAnnotation"("pdfUrl");
CREATE INDEX "PDFAnnotation_userId_idx" ON "PDFAnnotation"("userId");
CREATE INDEX "PDFAnnotation_userId_pdfUrl_idx" ON "PDFAnnotation"("userId", "pdfUrl");

-- 6. 授予权限
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO postgres;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO authenticated;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO anon;
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO service_role;

-- 7. 启用 RLS
ALTER TABLE "PDFAnnotation" ENABLE ROW LEVEL SECURITY;

-- 8. 创建策略
CREATE POLICY "用户只能查看自己的注释" ON "PDFAnnotation"
  FOR SELECT USING (auth.uid()::text = "userId");

CREATE POLICY "用户只能插入自己的注释" ON "PDFAnnotation"
  FOR INSERT WITH CHECK (auth.uid()::text = "userId");

CREATE POLICY "用户只能更新自己的注释" ON "PDFAnnotation"
  FOR UPDATE USING (auth.uid()::text = "userId");

CREATE POLICY "用户只能删除自己的注释" ON "PDFAnnotation"
  FOR DELETE USING (auth.uid()::text = "userId");

-- 9.为用户角色授权 public schema 权限。
-- 之前：用户有数据库 CREATE 权限就能在 public schema 中创建表
-- 现在：需要明确授权用户对 public schema 的权限

-- 为 authenticated 角色授权 public schema 权限
GRANT ALL ON SCHEMA public TO authenticated;

-- 为 anon 角色授权 public schema 权限（如果需要）
GRANT ALL ON SCHEMA public TO anon;

-- 为 service_role 角色授权 public schema 权限
GRANT ALL ON SCHEMA public TO service_role;

-- 确保所有表都有正确的权限
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO anon;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;

-- 为将来创建的表设置默认权限
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO service_role;
```

# 2.变更表结构同步到 Supabase

在开发阶段将 Prisma Schema 更新同步到 Supabase 的步骤：

### 1. 生成迁移 SQL

首先，使用 Prisma 生成迁移文件：

```bash
npx prisma migrate dev --name update_user_profile_schema
```

这会在 `prisma/migrations` 目录下生成包含 SQL 语句的迁移文件。

### 2. 将迁移应用到 Supabase

#### 方法一：使用 Supabase SQL 编辑器

1. 登录 [Supabase 控制台](https://app.supabase.com)
2. 选择您的项目
3. 进入 "SQL 编辑器" 标签
4. 创建新查询
5. 复制 Prisma 迁移文件中的 SQL 语句
6. 在 SQL 编辑器中粘贴并执行这些语句

#### 方法二：使用 Prisma 直接连接 Supabase（如果配置了直接连接）

如果您已经配置了 Prisma 直接连接 Supabase 数据库，可以执行：

```bash
DATABASE_URL=your_supabase_connection_string npx prisma migrate deploy
```

### 3. 更新本地 Prisma 客户端

应用迁移后，更新 Prisma 客户端：

```bash
npx prisma generate
```

### 4. 验证更改

在 Supabase 控制台中，进入 "表编辑器" 确认 `UserProfile` 表结构是否已正确更新：

- 检查是否添加了 `date` 字段
- 确认 `school` 字段是否已被移除或重命名
- 验证其他更改是否正确应用

### 提示与技巧

1. **开发中频繁更新**：在开发阶段频繁更改 schema 时，可以考虑：

   ```bash
   npx prisma db push
   ```

   这会直接将 schema 变更推送到数据库，但不会生成迁移历史

2. **导入与导出数据**：如果需要保留数据，可以先在 Supabase 中导出数据，应用迁移后再导入

3. **重置开发环境**：如果只是开发环境且数据不重要，可以考虑完全重置数据库：
   ```sql
   -- 在 Supabase SQL 编辑器中执行
   DROP SCHEMA public CASCADE;
   CREATE SCHEMA public;
   GRANT ALL ON SCHEMA public TO postgres;
   GRANT ALL ON SCHEMA public TO public;
   ```
   然后重新应用全部迁移

# 3.水和不匹配问题

1. **完全客户端渲染**：通过使用`mounted`状态和`useEffect`，确保 Toaster 和 TopLoader 组件只在客户端渲染，避免了服务器端和客户端之间的差异

2. **条件渲染**：服务器渲染时返回`null`，客户端挂载后才渲染实际组件

3. **明确的生命周期**：使用`useEffect`清晰地控制组件的挂载/卸载行为

通过这些改进，现在不应该再出现水合不匹配错误。这种方法是处理那些在服务器和客户端渲染结果不同的组件的最可靠方式。

4. 组件渲染的三个阶段
   - 服务器渲染：返回 null（不渲染任何内容）
   - 客户端初始渲染（水合）：返回 null（与服务器渲染结果匹配）
   - 客户端 useEffect 执行后：mounted=true，渲染实际组件
   - 这种模式特别适合处理那些依赖于浏览器环境、随机性、或会产生不一致渲染结果的组件，比如 toast 通知、进度条等 UI 元素。
   - 简而言之，这是一种"延迟客户端渲染"的技术，先确保水合成功，然后再在纯客户端环境中渲染实际内容。

# 4.什么时候用 Server Action?什么时候用 API 路由?

## 1. Server Action（服务器动作）

- **本质**：直接在服务端运行的函数，可以在组件/页面中直接调用（如 `await updateUser(data)`）。
- **调用方式**：只能在服务端（如 React Server Component、`app` 目录的 `server` 组件、或 `use server` 的 action）直接调用，不能被浏览器直接请求。
- **优点**：
  - 类型安全，参数和返回值都在同一个 TypeScript 项目里。
  - 无需手动写 API 路由，直接 import 调用。
  - 适合表单提交、数据处理、数据库操作等。
- **缺点**：
  - 只能在 Next.js 的服务端环境下用，不能被外部系统或 Postman 直接访问。
  - 不能处理 multipart/form-data（如文件上传）等特殊请求（目前）。

**你的 `actions/updateUser.ts` 就是一个 Server Action：**

```ts
// 只能在服务端直接 import 并调用
import { updateUser } from '@/actions/updateUser'
await updateUser(data)
```

---

## 2. API 路由（API Route）

- **本质**：一个 HTTP 接口（如 `/api/xxx`），可以被前端 fetch、axios、外部系统、Postman 等直接请求。
- **调用方式**：通过 HTTP 请求（GET/POST/PUT/DELETE），前端用 `fetch('/api/xxx')` 调用。
- **优点**：
  - 灵活，支持各种 HTTP 请求和内容类型（如文件上传）。
  - 可被任何客户端或第三方系统访问。
- **缺点**：
  - 需要手动处理请求体、参数校验、返回格式等。
  - 类型安全性不如 Server Action。

**API 路由例子：**

```ts
// app/api/update-user/route.ts
export async function POST(req: Request) {
  const data = await req.json()
  // ...处理逻辑
  return Response.json({ success: true })
}
```

### 2.1. `app/api/pdf2md/route.ts`（App Router 新写法）

- **属于 Next.js 13+ 的 App Router（app 目录）体系。**
- 文件路径：`app/api/pdf2md/route.ts`
- **导出方式**：导出 `GET`、`POST` 等函数（如 `export async function POST()`）。
- **支持特性**：
  - 支持 Edge/Server 运行时（可选）。
  - 支持中间件、流式响应等新特性。
  - 推荐用于新项目和未来维护。
- **调用方式**：前端 `fetch('/api/pdf2md', { method: 'POST', ... })`。

**示例：**

```ts
// app/api/pdf2md/route.ts
export async function POST(req: Request) {
  // 处理逻辑
  return Response.json({ markdown: '...' })
}
```

---

### 2.2 `pages/api/pdf2md.ts`（Pages Router 传统写法）

- **属于 Next.js 12 及以前的 Pages Router（pages 目录）体系。**
- 文件路径：`pages/api/pdf2md.ts`
- **导出方式**：导出一个默认的 handler 函数（`(req, res) => {}`）。
- **支持特性**：
  - 兼容老项目，写法和 Express 类似。
  - 不支持 Edge Runtime、流式响应等新特性。
  - 未来 Next.js 官方推荐逐步迁移到 app 目录。
- **调用方式**：前端 `fetch('/api/pdf2md', { method: 'POST', ... })`。

**示例：**

```ts
// pages/api/pdf2md.ts
export default async function handler(req, res) {
  // 处理逻辑
  res.status(200).json({ markdown: '...' })
}
```

---

## 3. 总结对比表

| 特性/区别        |   `app/api/pdf2md/route.ts`    |    `pages/api/pdf2md.ts`    |
| ---------------- | :----------------------------: | :-------------------------: |
| 所属体系         |     App Router（新，推荐）     |  Pages Router（老，兼容）   |
| Next.js 版本     |        13+（app 目录）         |   12 及以前（pages 目录）   |
| 导出方式         | `export async function POST()` | `export default function()` |
| Edge/Server 支持 |    支持 Edge/Server 运行时     |      仅 Node.js 运行时      |
| 新特性           |     支持流式响应、中间件等     |           不支持            |
| 官方推荐         |      新项目/未来维护优先       |        旧项目/兼容性        |

## 3. 什么时候用 Server Action，什么时候用 API 路由？

- **表单、按钮、数据更新**（只在 Next.js 内部用）：优先用 Server Action，代码更简洁、类型安全。
- **需要被外部系统/第三方/前端 fetch 调用**：用 API 路由。
- **文件上传、特殊请求体**：目前只能用 API 路由。

---

## 4. 你的项目举例

- `actions/updateUser.ts` 适合在 Next.js 内部直接调用（如表单提交）。
- 如果你要做“PDF 转 Markdown”，**必须用 API 路由**，因为要处理 multipart/form-data 文件上传，Server Action 暂不支持。

---

## 总结

| 场景          | Server Action（actions/xxx.ts） | API 路由（api/xxx/route.ts） |
| ------------- | :-----------------------------: | :--------------------------: |
| 内部表单/按钮 |            推荐使用             |             可用             |
| 外部系统调用  |              不行               |             推荐             |
| 文件上传      |              不行               |             推荐             |
| 类型安全      |             非常好              |          需手动校验          |

---

如需具体代码示例或集成建议，请随时告知！

# 5.通过 SQL 创建表可能导致权限问题

```SQL
-- 创建表后，可以运行以下SQL检查权限：
SELECT
    grantee,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE table_name = 'your_table_name'
ORDER BY grantee, privilege_type;

-- 如果没有权限

-- 1. 授予所有权限给 postgres 用户（表所有者）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO postgres;

-- 2. 授予所有权限给 authenticated 角色（认证用户）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO authenticated;

-- 3. 授予所有权限给 anon 角色（匿名用户）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO anon;

-- 4. 授予所有权限给 service_role 角色（服务角色）
GRANT ALL PRIVILEGES ON TABLE "PDFAnnotation" TO service_role;

```

## 5.1 预防措施

### 5.1.1 使用 Supabase Dashboard 创建表

- 通过 Dashboard 创建表会自动配置正确的权限,避免直接使用 SQL 创建表

# Supabase 客户端和 Prisma 客户端区别

### �� **实际情况分析**

#### 1. **Prisma 客户端**

- **不是** 处理本地数据库
- **而是** 处理 **线上 Supabase PostgreSQL 数据库**
- 从 `prisma/schema.prisma` 可以看到：
  ```prisma
  datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")      // 连接线上数据库
    directUrl = env("DIRECT_URL")        // 直接连接线上数据库
    schemas   = ["public"]
  }
  ```

#### 2. **Supabase 客户端**

- **不是** 只处理权限校验
- **而是** 提供完整的数据库操作功能
- 包括：认证、权限、实时订阅、数据库操作等

## 📊 **它们的关系和区别**

### **相同点：**

- 都连接 **同一个线上 Supabase PostgreSQL 数据库**
- 都可以进行数据库操作

### **不同点：**

| 特性         | Prisma 客户端         | Supabase 客户端   |
| ------------ | --------------------- | ----------------- |
| **类型安全** | ✅ 完全类型安全       | ❌ 需要手动处理   |
| **查询语言** | Prisma Query Language | SQL + 查询构建器  |
| **自动功能** | 自动生成 ID、默认值   | 需要手动处理      |
| **认证**     | ❌ 不处理认证         | ✅ 完整的认证系统 |
| **实时功能** | ❌ 不支持             | ✅ 实时订阅       |
| **权限控制** | ❌ 不处理             | ✅ RLS 策略       |

## 🔄 **数据流向**

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端组件      │    │   Prisma 客户端  │    │  Supabase 数据库 │
│                │    │                │    │                │
│ - 类型安全      │───▶│ - 自动生成 ID   │───▶│ - PostgreSQL    │
│ - 自动验证      │    │ - 默认值处理    │    │ - 表结构        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       ▲
         │                       │                       │
         ▼                       ▼                       │
┌─────────────────┐    ┌─────────────────┐              │
│   Supabase 客户端│    │   认证 & 权限    │              │
│                │    │                │              │
│ - 认证管理      │    │ - 用户会话      │              │
│ - 实时订阅      │    │ - RLS 策略      │──────────────┘
│ - 权限控制      │    │ - 服务角色      │
└─────────────────┘    └─────────────────┘
```

## �� **最佳实践建议**

### **混合使用模式：**

```typescript
// 1. 使用 Supabase 进行认证
const supabase = await createAdminClient()
const {
  data: { user },
} = await supabase.auth.getUser()

// 2. 使用 Prisma 进行数据库操作
const data = await prisma.category.create({
  data: {
    name: '技术',
    description: '技术相关文章',
  },
})
```

### **推荐使用场景：**

#### **使用 Prisma 客户端：**

- ✅ 数据库 CRUD 操作
- ✅ 复杂查询和关系
- ✅ 需要类型安全的地方
- ✅ 批量操作

#### **使用 Supabase 客户端：**

- ✅ 用户认证和授权
- ✅ 实时数据订阅
- ✅ 文件上传
- ✅ 需要 RLS 策略的地方

## 🎯 **总结**

1. **Prisma** 和 **Supabase** 都连接同一个线上数据库
2. **Prisma** 提供类型安全和自动功能
3. **Supabase** 提供认证、权限和实时功能
4. **建议混合使用**：认证用 Supabase，数据操作用 Prisma
5. **没有本地数据库**，都是操作线上 Supabase 数据库

您说得对，确实有点复杂！让我给您一个简单的判断标准：

## �� **简单判断标准**

### **使用 Supabase 客户端：**

1. **需要用户登录验证**
2. **需要检查用户权限**
3. **需要实时功能（如聊天）**
4. **需要文件上传**

### **使用 Prisma 客户端：**

1. **纯数据库操作（增删改查）**
2. **不需要用户验证的公开数据**
3. **复杂的数据库查询**

## 📋 **具体场景对照表**

| 场景             | 使用哪个 | 原因                  |
| ---------------- | -------- | --------------------- |
| 用户登录/注册    | Supabase | 需要认证              |
| 检查用户是否登录 | Supabase | 需要认证              |
| 创建博客文章     | **混合** | 需要认证 + 数据库操作 |
| 查看博客列表     | Prisma   | 纯数据库查询          |
| 删除文章         | **混合** | 需要认证 + 数据库操作 |
| 上传文件         | Supabase | 文件存储功能          |
| 实时聊天         | Supabase | 实时功能              |

## �� **简化方案**

### **方案一：全部用 Prisma（最简单）**

```typescript
// 所有数据库操作都用 Prisma
export async function createCategory(formData: TCategorySchema) {
  try {
    // 直接操作数据库，不做权限检查
    const data = await prisma.category.create({
      data: {
        name: formData.name,
        description: formData.description,
      },
    })
    return { success: true, data }
  } catch (error) {
    return { success: false, error: error.message }
  }
}
```

**优点：** 简单，代码少
**缺点：** 没有权限控制，不安全

### **方案二：全部用 Supabase（保持现状）**

```typescript
// 继续使用现有的 Supabase 方式
export async function createCategory(formData: TCategorySchema) {
  try {
    const supabase = await createAdminClient()
    const { data, error } = await supabase
      .from('Category')
      .insert({
        id: crypto.randomUUID(), // 手动生成 ID
        name: formData.name,
        description: formData.description,
      })
      .select()
      .single()

    return { success: true, data }
  } catch (error) {
    return { success: false, error: error.message }
  }
}
```

**优点：** 保持现有代码不变
**缺点：** 需要手动处理 ID 生成

### **方案三：混合使用（推荐）**

```typescript
// 认证用 Supabase，数据操作用 Prisma
export async function createCategory(formData: TCategorySchema) {
  try {
    // 1. 认证检查
    const supabase = await createAdminClient()
    const {
      data: { user },
    } = await supabase.auth.getUser()
    if (!user) throw new Error('请先登录')

    // 2. 数据操作
    const data = await prisma.category.create({
      data: {
        name: formData.name,
        description: formData.description,
      },
    })

    return { success: true, data }
  } catch (error) {
    return { success: false, error: error.message }
  }
}
```

## 🎯 **我的建议**

### **如果您想要简单：**

选择 **方案二（全部用 Supabase）**，只需要修复 ID 生成问题：

```typescript
// 在插入时手动生成 ID
.insert({
  id: crypto.randomUUID(), // 添加这行
  name: validatedData.name,
  description: validatedData.description,
})
```

### **如果您想要更好的开发体验：**

选择 **方案三（混合使用）**，但只在关键地方使用：

```typescript
// 只在需要权限的地方混合使用
// 其他地方都用 Prisma
```

## �� **快速决策指南**

**问自己：这个操作需要用户登录吗？**

- **需要登录** → 用 Supabase 或混合使用
- **不需要登录** → 用 Prisma

**问自己：这个操作涉及文件上传吗？**

- **涉及文件** → 用 Supabase
- **不涉及文件** → 用 Prisma

**问自己：这个操作需要实时更新吗？**

- **需要实时** → 用 Supabase
- **不需要实时** → 用 Prisma

这样判断就简单多了！您觉得哪种方案适合您？

## �� **Supabase 能否替代 Prisma？**

### **✅ Supabase 可以实现的：**

1. **数据库 CRUD 操作** ✅
2. **复杂查询** ✅
3. **关系查询** ✅
4. **类型安全** ✅ (通过 TypeScript)
5. **自动生成 ID** ✅ (通过数据库配置)
6. **权限控制** ✅ (RLS 策略)
7. **实时功能** ✅
8. **文件存储** ✅

### **❌ Supabase 的局限性：**

1. **类型安全不如 Prisma** (需要手动定义类型)
2. **查询语法相对复杂**
3. **没有自动的字段映射**
4. **需要手动处理默认值**

## 🎯 **推荐方案：纯 Supabase**

### **优点：**

1. **只需要学一套语法**
2. **功能完整** (认证、数据库、实时、文件)
3. **部署简单** (一个平台搞定)
4. **成本低** (免费额度大)

### **缺点：**

1. **类型安全不如 Prisma**
2. **查询语法相对复杂**
3. **需要手动处理一些细节**

### **实施步骤：**

1. **修复数据库表结构** (设置默认值)
2. **优化现有代码** (简化查询)
3. **创建服务类** (提高代码复用)
4. **添加类型定义** (提高类型安全)

## 🤔 **最终建议**

**如果您想要简单统一：**

- 选择 **纯 Supabase** 方案
- 修复数据库配置
- 优化查询语法
- 创建服务类封装

**如果您想要最佳开发体验：**

- 选择 **混合使用** 方案
- 认证用 Supabase
- 数据操作用 Prisma

您倾向于哪种方案？我可以帮您实施具体的代码修改。

# 什么是 Server Action,为何会出现以页面路径的 HTTP 请求

- 第一个问题：为何出现对 /zh/project 的请求

  - 这是 Next.js Server Actions 的正常行为。客户端调用 Server Action 时，浏览器会向“当前页面路由”发起一个 POST 请求，携带序列化的参数和一个内部的 action 标识，Next 在服务端把该请求路由到对应的 Server Action 执行。
  - 所以你看到的网络请求路径是当前页面 `/zh/project`，并不是你自己写了一个 `/project` 的 API。

- 第二个问题：账号密码为什么“未加密传输”
  - 你在本地是 http://localhost，用的是 HTTP 开发环境；浏览器开发者工具会展示你自己发起请求的明文参数，这与是否加密传输无关。真正的“传输层加密”依赖 HTTPS/TLS。
  - 生产环境使用 HTTPS 后，密码在网络上传输是加密的；浏览器开发者工具依然能看到本机即将发送的请求体，这是正常现象。
  - 不要在前端自行用 AES/RSA “加密密码”后再传，正确做法是：前端直接通过 HTTPS 发送明文密码，服务端（Supabase Auth）用 bcrypt 做不可逆哈希。你现在的方式是对的。

### 建议与检查清单

- 部署生产环境时启用 HTTPS（例如在 Vercel 默认就是 HTTPS）。需要可选地加一个强制 HTTPS 的中间件：
  ```ts
  // middleware.ts（可选）
  import { NextResponse } from 'next/server'
  import type { NextRequest } from 'next/server'
  export function middleware(req: NextRequest) {
    if (
      process.env.NODE_ENV === 'production' &&
      req.headers.get('x-forwarded-proto') !== 'https'
    ) {
      const url = req.nextUrl.clone()
      url.protocol = 'https:'
      return NextResponse.redirect(url)
    }
    return NextResponse.next()
  }
  ```
- 不要在任何日志/埋点中记录密码。你截图里有名为 track 的请求，注意排除敏感字段：
  ```ts
  // 发送埋点时仅发送 email 的哈希或去标识化信息，绝不发送 password
  analytics.track('login_submit', { email_hash: sha256(email) }) // 示例
  ```
- 使用 Supabase Auth 即可，不要重复实现密码加密。你的 `signIn` Server Action 已正确调用 `supabase.auth.signInWithPassword`。

- 如需让请求“不走当前路由路径”，只能改为使用 API Route/Route Handler；Server Actions 本身就是通过当前页面路由承载的，这一点是框架设计，属正常现象。
